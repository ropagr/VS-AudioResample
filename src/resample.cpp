// SPDX-License-Identifier: MIT

#include <climits>
#include <cstdint>
#include <cstring>
#include <format>
#include <string>
#include <type_traits>
#include <vector>

#include <samplerate.h>

#include "VapourSynth4.h"

#include "resample.hpp"
#include "common/sampletype.hpp"
#include "utils/sample.hpp"
#include "vsmap/vsmap.hpp"
#include "vsmap/vsmap_common.hpp"
#include "vsutils/audio.hpp"

#define FUNC_NAME "Resample"


// assuming SampleIntBits <= sizeof(sample_t) * CHAR_BIT
template <typename sample_t, size_t SampleIntBits>
constexpr size_t numBitShift = sizeof(sample_t) * CHAR_BIT - SampleIntBits;

template <typename sample_t, size_t SampleIntBits>
constexpr bool needsBitShift = std::is_integral_v<sample_t> && 0 < numBitShift<sample_t, SampleIntBits>;


static int64_t convSampleNum(int64_t srcSample, int srcSampleRate, int dstSampleRate)
{
    double srcSeconds = static_cast<double>(srcSample) / static_cast<double>(srcSampleRate);
    double dstSeconds = srcSeconds;
    int64_t dstSample = static_cast<int64_t>(std::round(dstSeconds * static_cast<double>(dstSampleRate)));
    return dstSample;
}


/**
 * calculate the estimated relative source buffer length
 */
static double calcEstRelSrcBufLen(int srcSampleRate, int dstSampleRate)
{
    if (dstSampleRate <= srcSampleRate)
    {
        // roughly 5% more needed -> make it 10% just to be sure
        return 1.1;
    }

    // srcSampleRate < dstSampleRate

    // multiplier purely based on practical experience
    constexpr double RelScalingFactor = 0.06;

    return static_cast<double>(dstSampleRate) / static_cast<double>(srcSampleRate) * RelScalingFactor + 1.0;
}


Resample::Resample(VSNode* _srcAudio, const VSAudioInfo* _srcAi, int _dstSampleRate, common::SampleType _dstSampleType,
                   int _convType, VSCore* core, const VSAPI* vsapi) :
    srcAudio(_srcAudio), srcAi(_srcAi), dstSampleRate(_dstSampleRate), dstSampleType(_dstSampleType),
    convType(_convType), numChannels(_srcAi->format.numChannels)
{
    // destination audio information
    dstAi = *srcAi;
    dstAi.sampleRate = dstSampleRate;

    if (srcAi->sampleRate != dstSampleRate)
    {
        // only overwrite numSamples and numFrames when resampling is required
        dstAi.numSamples = convSampleNum(srcAi->numSamples, srcAi->sampleRate, dstSampleRate);
        dstAi.numFrames = vsutils::samplesToFrames(dstAi.numSamples);
    }

    common::applySampleTypeToAudioFormat(dstSampleType, &dstAi.format);

    srcSampleType = common::getSampleTypeFromAudioFormat(&srcAi->format);

    // buffer more input samples than one output frame actually requires
    // because libsamplerate needs more input samples to resample one full output frame
    double relSrcBufLen = calcEstRelSrcBufLen(srcAi->sampleRate, dstSampleRate);

    // make the output buffer bigger than the input buffer (relatively) to store all output samples
    // generated by input samples including those that exceed the current frame
    double relDstBufLen = relSrcBufLen + 0.1;

    srcBufLenInSamples = static_cast<size_t>(convSampleNum(VS_AUDIO_FRAME_SAMPLES, dstSampleRate, srcAi->sampleRate) * relSrcBufLen);
    srcBuf = new float[srcBufLenInSamples * numChannels];

    dstBufLenInSamples = static_cast<size_t>(VS_AUDIO_FRAME_SAMPLES * relDstBufLen);
    dstBuf = new float[dstBufLenInSamples * numChannels];

    int err;
    resState = src_new(convType, numChannels, &err);
    if (err)
    {
        std::string msg = std::format(FUNC_NAME ": src_new error: {}", src_strerror(err));
        vsapi->logMessage(VSMessageType::mtFatal, msg.c_str(), core);
        return;
    }
}


VSNode* Resample::getSrcAudio()
{
    return srcAudio;
}


const VSAudioInfo* Resample::getSrcAudioInfo()
{
    return srcAi;
}


const VSAudioInfo* Resample::getDstAudioInfo()
{
    return &dstAi;
}


size_t Resample::getSrcBufLengthInSamples()
{
    return srcBufLenInSamples;
}


void Resample::free(const VSAPI* vsapi)
{
    vsapi->freeNode(srcAudio);

    src_delete(resState);

    delete[] srcBuf;
    delete[] dstBuf;
}


template <typename src_sample_t, size_t SrcSampleIntBits, typename dst_sample_t, size_t DstSampleIntBits>
void Resample::writeFrameNoResamplingImpl(VSFrame* dstFrame, const VSFrame* srcFrame, int samples, const VSAPI* vsapi)
{
    // for 24-bit audio samples stored in int32_t
    constexpr size_t srcNumBitShift = numBitShift<src_sample_t, SrcSampleIntBits>;
    constexpr bool srcNeedsBitShift = needsBitShift<src_sample_t, SrcSampleIntBits>;

    // for 24-bit audio samples stored in int32_t
    constexpr size_t dstNumBitShift = numBitShift<dst_sample_t, DstSampleIntBits>;
    constexpr bool dstNeedsBitShift = needsBitShift<dst_sample_t, DstSampleIntBits>;

    for (int ch = 0; ch < numChannels; ++ch)
    {
        const src_sample_t* srcFrameReadPtr = reinterpret_cast<const src_sample_t*>(vsapi->getReadPtr(srcFrame, ch));
        dst_sample_t* dstFrameWritePtr = reinterpret_cast<dst_sample_t*>(vsapi->getWritePtr(dstFrame, ch));

        for (int s = 0; s < samples; ++s)
        {
            src_sample_t srcSample = srcFrameReadPtr[s];
            if constexpr (srcNeedsBitShift)
            {
                // only for 24-bit integer samples
                srcSample >>= srcNumBitShift;
            }

            dst_sample_t dstSample = utils::convSampleType<src_sample_t, SrcSampleIntBits, dst_sample_t, DstSampleIntBits>(srcSample);

            if constexpr (dstNeedsBitShift)
            {
                // only for 24-bit integer samples
                dstSample <<= dstNumBitShift;
            }

            dstFrameWritePtr[s] = dstSample;
        }
    }
}


/**
 * fills the buffer 'buf' with samples from all channels from 'firstSrcSampleTotal' to 'lastSrcSampleTotal' (both inclusive)
 * samples will be stored interleaved, i.e. one sample of each channel next to each other
 * obviously the provided source frames should cover the specified sample range
 */
template <typename src_sample_t, size_t SrcSampleIntBits>
int Resample::fillInterleavedSamples(float* buf, size_t bufLenInSamples, int64_t firstSrcSampleTotal, int64_t lastSrcSampleTotal,
                                     std::vector<const VSFrame*> const &srcFrames, int firstSrcFrameTotal, const VSAPI* vsapi)
{
    // for 24-bit audio samples stored in int32_t
    constexpr size_t srcNumBitShift = numBitShift<src_sample_t, SrcSampleIntBits>;
    constexpr bool srcNeedsBitShift = needsBitShift<src_sample_t, SrcSampleIntBits>;

    // firstSrcFrameTotal might not necessarily be the frame of firstSrcSampleTotal
    int firstSampleFrameTotal = vsutils::sampleToFrame(firstSrcSampleTotal);

    // inclusive
    int lastSampleFrameTotal = vsutils::sampleToFrame(lastSrcSampleTotal);

    int addedSamples = 0;

    for (int f = firstSampleFrameTotal; f <= lastSampleFrameTotal; ++f)
    {
        // first sample in frame (inclusive)
        int firstFrameSample = f == firstSampleFrameTotal ? static_cast<int>(firstSrcSampleTotal % VS_AUDIO_FRAME_SAMPLES) : 0;

        // last sample in frame (inclusive)
        int lastFrameSample = f == lastSampleFrameTotal ? static_cast<int>(lastSrcSampleTotal % VS_AUDIO_FRAME_SAMPLES) : VS_AUDIO_FRAME_SAMPLES - 1;

        // number of samples in frame
        int frameSamples = lastFrameSample - firstFrameSample + 1;

        for (int ch = 0; ch < numChannels; ++ch)
        {
            const src_sample_t* srcFrmReadPtr = reinterpret_cast<const src_sample_t*>(vsapi->getReadPtr(srcFrames[f - firstSrcFrameTotal], ch));

            for (int s = 0; s < frameSamples; ++s)
            {
                src_sample_t sample = srcFrmReadPtr[firstFrameSample + s];
                if constexpr (srcNeedsBitShift)
                {
                    // only for 24-bit integer samples
                    sample >>= srcNumBitShift;
                }

                buf[(addedSamples + s) * numChannels + ch] = utils::convSampleType<src_sample_t, SrcSampleIntBits, float, 0>(sample);
            }
        }

        addedSamples += frameSamples;
    }

    return addedSamples;
}


template <typename src_sample_t, size_t SrcSampleIntBits, typename dst_sample_t, size_t DstSampleIntBits>
void Resample::writeFrameImpl(VSFrame* dstFrame, int dstFrameTotal, int dstFrameSamples,
                              int64_t firstSrcSampleTotal, int64_t lastSrcSampleTotal, bool srcSamplesEnd,
                              std::vector<const VSFrame*> const &srcFrames, int firstSrcFrameTotal,
                              VSFrameContext* frameCtx, VSCore* core, const VSAPI* vsapi)
{
    // srcSamplesEnd: no more source samples available if true,
    //                but it does not necessarily mean that this is the last destination frame!

    if (srcAi->sampleRate == dstAi.sampleRate && srcFrames.size() == 1)
    {
        writeFrameNoResamplingImpl<src_sample_t, SrcSampleIntBits, dst_sample_t, DstSampleIntBits>(
                dstFrame, srcFrames[0], dstFrameSamples, vsapi);
        return;
    }

    if (lastDstFrameTotal + 1 == dstFrameTotal)
    {
        // subsequent frame
        // there are probably aleady some consumed source samples which should not be consumed again
        if (firstSrcSampleTotal <= lastConsumedSrcSampleTotal)
        {
            firstSrcSampleTotal = lastConsumedSrcSampleTotal + 1;
        }
        else
        {
            // lastConsumedSrcSampleTotal < firstSrcSampleTotal
            // not supposed to happen since we always consume more source samples than needed
            std::string msg = std::format(FUNC_NAME ": Missing source samples (frame: {}): last consumed source sample: {}, next source sample: {}",
                                          dstFrameTotal, lastConsumedSrcSampleTotal, firstSrcSampleTotal);
            vsapi->logMessage(VSMessageType::mtCritical, msg.c_str(), core);
        }
    }
    else
    {
        // current frame is NOT a subsequent frame -> reset resampler state and destination buffer
        dstBufSamples = 0;

        src_reset(resState);
    }

    // can safely be casted to an int since the number of source samples
    // will not exceed 256 * VS_AUDIO_FRAME_SAMPLES (3072) = 786432
    // with 256 being the maximum resampling factor of libsamplerate
    int srcSamples = static_cast<int>(lastSrcSampleTotal - firstSrcSampleTotal + 1);

    // in rare cases all source samples are already consumed before the last destination frame -> srcSamples <= 0
    if (0 < srcSamples)
    {
        // fill source buffer
        int readSamples = fillInterleavedSamples<src_sample_t, SrcSampleIntBits>(
                srcBuf, srcBufLenInSamples, firstSrcSampleTotal, lastSrcSampleTotal, srcFrames, firstSrcFrameTotal, vsapi);

        if (readSamples != srcSamples)
        {
            std::string msg = std::format(FUNC_NAME ": Not all requested input samples read (frame: {}): read: {} / {}",
                                          dstFrameTotal, readSamples, srcSamples);
            vsapi->logMessage(VSMessageType::mtCritical, msg.c_str(), core);
        }

        // resample data
        SRC_DATA resData = {
            .data_in = srcBuf,
            // there might be 'dstBufSamples' samples stored in 'dstBuf' which was produced
            // in the previous destination frame by source samples that cover more than the destination frame
            .data_out = &dstBuf[dstBufSamples * numChannels],
            .input_frames = srcSamples,
            .output_frames = static_cast<long>(dstBufLenInSamples - dstBufSamples),
            .input_frames_used = 0,
            .output_frames_gen = 0,
            .end_of_input = static_cast<int>(srcSamplesEnd),
            .src_ratio = static_cast<double>(dstAi.sampleRate) / static_cast<double>(srcAi->sampleRate),
        };

        // resample samples in source buffer
        int err = src_process(resState, &resData);
        if (err)
        {
            std::string msg = std::format(FUNC_NAME ": src_process error (frame: {}): {}", dstFrameTotal, src_strerror(err));
            vsapi->logMessage(VSMessageType::mtCritical, msg.c_str(), core);
            return;
        }

        lastConsumedSrcSampleTotal = firstSrcSampleTotal + resData.input_frames_used - 1;

        // Note: one frame in libsamplerate is one sample of each channel
        dstBufSamples += resData.output_frames_gen;
    }

    // handle output samples

    if (dstBufSamples < dstFrameSamples)
    {
        int numMissingSamples = dstFrameSamples - dstBufSamples;

        // unfortunately this can happen for the last audio frame (depending on the samplerates)
        // it seems the number of output samples of libsamplerate is somewhat unpredictable
        // which makes it very difficult to use for VapourSynth where you have to know the number
        // of output samples in advance
        // see discussion: https://github.com/libsndfile/libsamplerate/issues/175

        if (dstFrameTotal == dstAi.numFrames - 1)
        {
            // last frame
            std::string msg = std::format(FUNC_NAME ": src_process (frame: {}): Not enough output samples generated for the last frame: {} / {}, "
                                                    "last {} sample(s) will be muted (this is a known issue, please see the docs for more)",
                                          dstFrameTotal, dstBufSamples, dstFrameSamples, numMissingSamples);
            // only send a warning
            vsapi->logMessage(VSMessageType::mtWarning, msg.c_str(), core);
        }
        else
        {
            // not supposed to happen
            std::string msg = std::format(FUNC_NAME ": src_process (frame: {}): Not enough output samples generated: {} / {}, missing samples: {}",
                                          dstFrameTotal, dstBufSamples, dstFrameSamples, numMissingSamples);
            // this is indeed critical
            vsapi->logMessage(VSMessageType::mtCritical, msg.c_str(), core);
        }

        // mute missing samples
        std::memset(&dstBuf[dstBufSamples * numChannels], 0, sizeof(float) * (dstFrameSamples - dstBufSamples) * numChannels);

        dstBufSamples = dstFrameSamples;
    }

    int dstBufSamplesToWrite = dstFrameSamples;

    // for 24-bit audio samples stored in int32_t
    constexpr size_t dstNumBitShift = numBitShift<dst_sample_t, DstSampleIntBits>;
    constexpr bool dstNeedsBitShift = needsBitShift<dst_sample_t, DstSampleIntBits>;

    // write resampled data to destination frame
    for (int ch = 0; ch < numChannels; ++ch)
    {
        dst_sample_t* dstFrmWritePtr = reinterpret_cast<dst_sample_t*>(vsapi->getWritePtr(dstFrame, ch));

        for (int s = 0; s < dstBufSamplesToWrite; ++s)
        {
            dst_sample_t dstSample = utils::convSampleType<float, 0, dst_sample_t, DstSampleIntBits>(dstBuf[ch + s * numChannels]);

            if constexpr (dstNeedsBitShift)
            {
                // only for 24-bit integer samples
                dstSample <<= dstNumBitShift;
            }

            dstFrmWritePtr[s] = dstSample;
        }
    }

    // shift remaining ouput samples to the left
    int dstBufSamplesToShift = dstBufSamples - dstBufSamplesToWrite;

    for (int s = 0; s < dstBufSamplesToShift; ++s)
    {
        std::memcpy(&dstBuf[s * numChannels], &dstBuf[(dstBufSamplesToWrite + s) * numChannels], sizeof(float) * numChannels);
    }

    dstBufSamples = dstBufSamplesToShift;

    lastDstFrameTotal = dstFrameTotal;
}


void Resample::writeFrame(VSFrame* dstFrame, int dstFrameTotal, int dstFrameSamples,
                          int64_t firstSrcSampleTotal, int64_t lastSrcSampleTotal, bool srcSamplesEnd,
                          std::vector<const VSFrame*> const &srcFrames, int firstSrcFrameTotal,
                          VSFrameContext* frameCtx, VSCore* core, const VSAPI* vsapi)
{
    if (srcSampleType == common::SampleType::Int16)
    {
        switch (dstSampleType)
        {
        case common::SampleType::Int16:
            writeFrameImpl<int16_t, 16, int16_t, 16>(dstFrame, dstFrameTotal, dstFrameSamples, firstSrcSampleTotal, lastSrcSampleTotal, srcSamplesEnd, srcFrames, firstSrcFrameTotal, frameCtx, core, vsapi);
            break;
        case common::SampleType::Int24:
            writeFrameImpl<int16_t, 16, int32_t, 24>(dstFrame, dstFrameTotal, dstFrameSamples, firstSrcSampleTotal, lastSrcSampleTotal, srcSamplesEnd, srcFrames, firstSrcFrameTotal, frameCtx, core, vsapi);
            break;
        case common::SampleType::Int32:
            writeFrameImpl<int16_t, 16, int32_t, 32>(dstFrame, dstFrameTotal, dstFrameSamples, firstSrcSampleTotal, lastSrcSampleTotal, srcSamplesEnd, srcFrames, firstSrcFrameTotal, frameCtx, core, vsapi);
            break;
        case common::SampleType::Float32:
            writeFrameImpl<int16_t, 16, float, 0>(dstFrame, dstFrameTotal, dstFrameSamples, firstSrcSampleTotal, lastSrcSampleTotal, srcSamplesEnd, srcFrames, firstSrcFrameTotal, frameCtx, core, vsapi);
            break;
        default:
            break;
        }
        return;
    }

    if (srcSampleType == common::SampleType::Int24)
    {
        switch (dstSampleType)
        {
        case common::SampleType::Int16:
            writeFrameImpl<int32_t, 24, int16_t, 16>(dstFrame, dstFrameTotal, dstFrameSamples, firstSrcSampleTotal, lastSrcSampleTotal, srcSamplesEnd, srcFrames, firstSrcFrameTotal, frameCtx, core, vsapi);
            break;
        case common::SampleType::Int24:
            writeFrameImpl<int32_t, 24, int32_t, 24>(dstFrame, dstFrameTotal, dstFrameSamples, firstSrcSampleTotal, lastSrcSampleTotal, srcSamplesEnd, srcFrames, firstSrcFrameTotal, frameCtx, core, vsapi);
            break;
        case common::SampleType::Int32:
            writeFrameImpl<int32_t, 24, int32_t, 32>(dstFrame, dstFrameTotal, dstFrameSamples, firstSrcSampleTotal, lastSrcSampleTotal, srcSamplesEnd, srcFrames, firstSrcFrameTotal, frameCtx, core, vsapi);
            break;
        case common::SampleType::Float32:
            writeFrameImpl<int32_t, 24, float, 0>(dstFrame, dstFrameTotal, dstFrameSamples, firstSrcSampleTotal, lastSrcSampleTotal, srcSamplesEnd, srcFrames, firstSrcFrameTotal, frameCtx, core, vsapi);
            break;
        default:
            break;
        }
        return;
    }

    if (srcSampleType == common::SampleType::Int32)
    {
        switch (dstSampleType)
        {
        case common::SampleType::Int16:
            writeFrameImpl<int32_t, 32, int16_t, 16>(dstFrame, dstFrameTotal, dstFrameSamples, firstSrcSampleTotal, lastSrcSampleTotal, srcSamplesEnd, srcFrames, firstSrcFrameTotal, frameCtx, core, vsapi);
            break;
        case common::SampleType::Int24:
            writeFrameImpl<int32_t, 32, int32_t, 24>(dstFrame, dstFrameTotal, dstFrameSamples, firstSrcSampleTotal, lastSrcSampleTotal, srcSamplesEnd, srcFrames, firstSrcFrameTotal, frameCtx, core, vsapi);
            break;
        case common::SampleType::Int32:
            writeFrameImpl<int32_t, 32, int32_t, 32>(dstFrame, dstFrameTotal, dstFrameSamples, firstSrcSampleTotal, lastSrcSampleTotal, srcSamplesEnd, srcFrames, firstSrcFrameTotal, frameCtx, core, vsapi);
            break;
        case common::SampleType::Float32:
            writeFrameImpl<int32_t, 32, float, 0>(dstFrame, dstFrameTotal, dstFrameSamples, firstSrcSampleTotal, lastSrcSampleTotal, srcSamplesEnd, srcFrames, firstSrcFrameTotal, frameCtx, core, vsapi);
            break;
        default:
            break;
        }
        return;
    }

    if (srcSampleType == common::SampleType::Float32)
    {
        switch (dstSampleType)
        {
        case common::SampleType::Int16:
            writeFrameImpl<float, 0, int16_t, 16>(dstFrame, dstFrameTotal, dstFrameSamples, firstSrcSampleTotal, lastSrcSampleTotal, srcSamplesEnd, srcFrames, firstSrcFrameTotal, frameCtx, core, vsapi);
            break;
        case common::SampleType::Int24:
            writeFrameImpl<float, 0, int32_t, 24>(dstFrame, dstFrameTotal, dstFrameSamples, firstSrcSampleTotal, lastSrcSampleTotal, srcSamplesEnd, srcFrames, firstSrcFrameTotal, frameCtx, core, vsapi);
            break;
        case common::SampleType::Int32:
            writeFrameImpl<float, 0, int32_t, 32>(dstFrame, dstFrameTotal, dstFrameSamples, firstSrcSampleTotal, lastSrcSampleTotal, srcSamplesEnd, srcFrames, firstSrcFrameTotal, frameCtx, core, vsapi);
            break;
        case common::SampleType::Float32:
            writeFrameImpl<float, 0, float, 0>(dstFrame, dstFrameTotal, dstFrameSamples, firstSrcSampleTotal, lastSrcSampleTotal, srcSamplesEnd, srcFrames, firstSrcFrameTotal, frameCtx, core, vsapi);
            break;
        default:
            break;
        }
        return;
    }
}


static void VS_CC resampleFree(void* instanceData, VSCore* core, const VSAPI* vsapi)
{
    Resample* data = reinterpret_cast<Resample*>(instanceData);
    data->free(vsapi);

    delete data;
}


static const VSFrame* VS_CC resampleGetFrame(int dstFrameTotal, int activationReason, void* instanceData, void** frameData, VSFrameContext* frameCtx, VSCore* core, const VSAPI* vsapi)
{
    Resample* data = reinterpret_cast<Resample*>(instanceData);

    // inclusive
    int64_t firstDstSampleTotal = dstFrameTotal * VS_AUDIO_FRAME_SAMPLES;
    // inclusive
    int64_t lastDstSampleTotal = dstFrameTotal == data->getDstAudioInfo()->numFrames - 1 ?
            data->getDstAudioInfo()->numSamples - 1 : (dstFrameTotal + 1) * VS_AUDIO_FRAME_SAMPLES - 1;

    int dstFrameSamples = static_cast<int>(lastDstSampleTotal - firstDstSampleTotal + 1);

    // inclusive
    int64_t firstSrcSampleTotal;
    // inclusive
    int64_t lastSrcSampleTotal;

    bool srcSamplesEnd = false;

    if (data->getSrcAudioInfo()->sampleRate == data->getDstAudioInfo()->sampleRate)
    {
        // no resampling required, avoid any rounding errors
        firstSrcSampleTotal = firstDstSampleTotal;
        lastSrcSampleTotal = lastDstSampleTotal;
    }
    else
    {
        firstSrcSampleTotal = convSampleNum(firstDstSampleTotal, data->getDstAudioInfo()->sampleRate, data->getSrcAudioInfo()->sampleRate);
        lastSrcSampleTotal = firstSrcSampleTotal + data->getSrcBufLengthInSamples() - 1;
    }

    if (data->getSrcAudioInfo()->numSamples - 1 < lastSrcSampleTotal)
    {
        srcSamplesEnd = true;
        lastSrcSampleTotal = data->getSrcAudioInfo()->numSamples - 1;
    }

    // inclusive
    int firstSrcFrameTotal = vsutils::sampleToFrame(firstSrcSampleTotal);
    // inclusive
    int lastSrcFrameTotal = vsutils::sampleToFrame(lastSrcSampleTotal);

    int srcFramesLen = lastSrcFrameTotal - firstSrcFrameTotal + 1;

    if (activationReason == VSActivationReason::arInitial)
    {
        for (int i = 0; i < srcFramesLen; ++i)
        {
            vsapi->requestFrameFilter(firstSrcFrameTotal + i, data->getSrcAudio(), frameCtx);
        }

        return nullptr;
    }

    if (activationReason == VSActivationReason::arAllFramesReady)
    {
        std::vector<const VSFrame*> srcFrames;
        srcFrames.resize(srcFramesLen);

        for (int i = 0; i < srcFramesLen; ++i)
        {
            srcFrames[i] = vsapi->getFrameFilter(firstSrcFrameTotal + i, data->getSrcAudio(), frameCtx);
        }

        VSFrame* dstFrame = vsapi->newAudioFrame(&data->getDstAudioInfo()->format, dstFrameSamples, nullptr, core);

        data->writeFrame(dstFrame, dstFrameTotal, dstFrameSamples,
                         firstSrcSampleTotal, lastSrcSampleTotal, srcSamplesEnd,
                         srcFrames, firstSrcFrameTotal, frameCtx, core, vsapi);

        for (int i = 0; i < srcFramesLen; ++i)
        {
            vsapi->freeFrame(srcFrames[i]);
        }

        return dstFrame;
    }

    return nullptr;
}


static void VS_CC resampleCreate(const VSMap* in, VSMap* out, void* userData, VSCore* core, const VSAPI* vsapi)
{
    // audio:anode
    VSNode* srcAudio = nullptr;
    if (!vsmap::getAudioClip("audio", FUNC_NAME, in, out, vsapi, &srcAudio))
    {
        return;
    }

    const VSAudioInfo* srcAi = vsapi->getAudioInfo(srcAudio);

    // check for supported audio format
    switch (common::getSampleTypeFromAudioFormat(&srcAi->format))
    {
    case common::SampleType::Int16:
    case common::SampleType::Int24:
    case common::SampleType::Int32:
    case common::SampleType::Float32:
        // OK
        break;
    default:
        vsapi->mapSetError(out, FUNC_NAME ": audio format not supported");
        vsapi->freeNode(srcAudio);
        return;
    }

    // sample_rate:int:opt
    int sampleRate;
    if (!vsmap::getOptInt("sample_rate", FUNC_NAME, in, out, vsapi, &sampleRate, -1))
    {
        vsapi->freeNode(srcAudio);
        return;
    }

    if (sampleRate <= 0)
    {
        sampleRate = srcAi->sampleRate;
    }

    double sampleRateRatio = static_cast<double>(sampleRate) / static_cast<double>(srcAi->sampleRate);
    if (!src_is_valid_ratio(sampleRateRatio))
    {
        vsapi->mapSetError(out, FUNC_NAME ": sample rate ratio not supported");
        vsapi->freeNode(srcAudio);
        return;
    }

    // sample_type:int:opt
    // sample_type_s:data:opt
    common::SampleType sampleType = vsmap::getOptSampleType("sample_type", "sample_type_s", in, out, vsapi, common::getSampleTypeFromAudioFormat(&srcAi->format));

    switch (sampleType)
    {
    case common::SampleType::Int16:
    case common::SampleType::Int24:
    case common::SampleType::Int32:
    case common::SampleType::Float32:
        // OK
        break;
    default:
        vsapi->mapSetError(out, FUNC_NAME ": sample type not supported");
        vsapi->freeNode(srcAudio);
        return;
    }

    // conv_type:int:opt
    int convType;
    if (!vsmap::getOptInt("conv_type", FUNC_NAME, in, out, vsapi, &convType, SRC_SINC_BEST_QUALITY))
    {
        vsapi->freeNode(srcAudio);
        return;
    }

    switch (convType)
    {
    case SRC_SINC_BEST_QUALITY:
    case SRC_SINC_MEDIUM_QUALITY:
    case SRC_SINC_FASTEST:
    case SRC_ZERO_ORDER_HOLD:
    case SRC_LINEAR:
        // OK
        break;
    default:
        vsapi->mapSetError(out, FUNC_NAME ": conversion type not supported");
        vsapi->freeNode(srcAudio);
        return;
    }

    Resample* data = new Resample(srcAudio, srcAi, sampleRate, sampleType, convType, core, vsapi);

    VSFilterDependency deps[] = {{srcAudio, VSRequestPattern::rpGeneral}};

    // fmParallelRequests: strict sequential frame requests
    vsapi->createAudioFilter(out, FUNC_NAME, data->getDstAudioInfo(), resampleGetFrame, resampleFree, VSFilterMode::fmParallelRequests, deps, 1, data, core);
}


void resampleInit(VSPlugin* plugin, const VSPLUGINAPI* vspapi)
{
    vspapi->registerFunction(FUNC_NAME,
                             "audio:anode;"
                             "sample_rate:int:opt;"
                             "sample_type:int:opt;"
                             "sample_type_s:data:opt;"
                             "conv_type:int:opt;",
                             "return:anode;",
                             resampleCreate, nullptr, plugin);
}

#undef FUNC_NAME
